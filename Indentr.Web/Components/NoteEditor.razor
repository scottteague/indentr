@inject AppSession Session
@inject NoteChangeNotifier Notifier
@inject IJSRuntime JS
@inject NavigationManager Nav
@implements IAsyncDisposable

@if (_note is not null)
{
    <div class="note-editor">
        <div class="note-header">
            @if (_note.IsRoot)
            {
                <h1 class="note-title">@_note.Title</h1>
            }
            else
            {
                <input class="note-title-input"
                       value="@_currentTitle"
                       @oninput="OnTitleInput"
                       @onblur="OnTitleBlur"
                       @onkeydown="OnTitleKeyDown" />
            }
            <div class="note-actions">
                @if (_saving)
                {
                    <span class="status-text">Saving…</span>
                }
                else if (_conflictMessage is not null)
                {
                    <span class="status-conflict">@_conflictMessage</span>
                }
                @if (!_note.IsRoot)
                {
                    <button class="btn-trash" @onclick="MoveToTrashAsync"
                            disabled="@(_saving || _deleting)">Move to Trash</button>
                }
                <button class="btn-save" @onclick="SaveAsync" disabled="@(_saving || _deleting)">Save</button>
            </div>
        </div>

        @if (_attachments.Count > 0)
        {
            <div class="attachments">
                <strong>Attachments:</strong>
                @foreach (var att in _attachments)
                {
                    <a href="/api/attachments/@att.Id" target="_blank" class="attachment-link">
                        @att.Filename
                    </a>
                }
            </div>
        }

        <div id="@_editorId" class="cm-host"></div>
    </div>
}
else if (_notFound)
{
    <div class="note-missing">Note not found.</div>
}
else
{
    <div class="note-missing">Loading…</div>
}

@code {
    [Parameter, EditorRequired] public Guid NoteId { get; set; }

    private Note?   _note;
    private bool    _notFound;
    private bool    _saving;
    private bool    _deleting;
    private bool    _isDirty;
    private bool    _titleDirty;
    private string? _conflictMessage;
    private string  _currentContent = "";
    private string  _currentTitle   = "";
    private string  _editorId = "";
    private IReadOnlyList<AttachmentMeta> _attachments = [];
    private CancellationTokenSource? _saveCts;

    private IJSObjectReference?         _module;
    private DotNetObjectReference<NoteEditor>? _dotNetRef;
    private bool _editorInitialized;

    protected override async Task OnInitializedAsync()
    {
        _editorId = $"cm-{NoteId:N}";
        Notifier.NoteChanged += HandleChange;
        await LoadNoteAsync();
    }

    private async Task LoadNoteAsync()
    {
        if (Session.Notes is null || Session.Attachments is null || Session.CurrentUser is null) return;

        var note = await Session.Notes.GetByIdAsync(NoteId);
        if (note is null) { _notFound = true; return; }

        // Privacy guard
        if (note.IsPrivate && note.CreatedBy != Session.CurrentUser.Id)
        {
            Nav.NavigateTo("/");
            return;
        }

        _note = note;
        _currentContent = note.Content;
        _currentTitle   = note.Title;
        _attachments = await Session.Attachments.ListForNoteAsync(NoteId);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_editorInitialized || _note is null) return;
        _editorInitialized = true; // guard before first await to prevent double-init

        _module     = await JS.InvokeAsync<IJSObjectReference>("import", "/js/editor.js");
        _dotNetRef  = DotNetObjectReference.Create(this);
        await _module.InvokeVoidAsync("create", _editorId, _note.Content, _dotNetRef);
    }

    [JSInvokable]
    public void OnContentChanged(string content)
    {
        _currentContent = content;
        _isDirty = true;

        // Debounce: cancel any pending auto-save and schedule a new one.
        _saveCts?.Cancel();
        _saveCts?.Dispose();
        _saveCts = new CancellationTokenSource();
        var token = _saveCts.Token;
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(3000, token);
                await InvokeAsync(SaveAsync);
            }
            catch (OperationCanceledException) { }
        });
    }

    [JSInvokable]
    public Task SaveFromKeyboard() => SaveAsync();

    [JSInvokable]
    public void OnLinkClicked(string target)
    {
        if (target.StartsWith("note:") && Guid.TryParse(target[5..], out var id))
            _ = JS.InvokeVoidAsync("open", $"/note/{id}", "_blank");
        else if (!target.StartsWith("kanban:"))
            _ = JS.InvokeVoidAsync("open", target, "_blank");
    }

    private async Task MoveToTrashAsync()
    {
        if (_note is null || Session.Notes is null) return;
        var ok = await JS.InvokeAsync<bool>("confirm", $"Move \"{_note.Title}\" to Trash?");
        if (!ok) return;

        _deleting = true;
        StateHasChanged();
        try
        {
            await Session.Notes.DeleteAsync(NoteId);
            Notifier.NotifyChanged(NoteId);
            Nav.NavigateTo("/");
        }
        finally
        {
            _deleting = false;
        }
    }

    private void OnTitleInput(ChangeEventArgs e)
    {
        _currentTitle = e.Value?.ToString() ?? "";
        _titleDirty   = _currentTitle != _note!.Title;
    }

    private async Task OnTitleBlur()
    {
        if (_titleDirty) await SaveTitleAsync();
    }

    private async Task OnTitleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await SaveTitleAsync();
    }

    private async Task SaveTitleAsync()
    {
        if (_note is null || !_titleDirty) return;
        var trimmed = _currentTitle.Trim();
        if (string.IsNullOrEmpty(trimmed))
        {
            // Revert to the last saved title.
            _currentTitle = _note.Title;
            _titleDirty   = false;
            StateHasChanged();
            return;
        }
        _titleDirty   = false;
        _note.Title   = trimmed;
        _currentTitle = trimmed;
        await SaveAsync();
    }

    private async Task SaveAsync()
    {
        if (_note is null || Session.Notes is null) return;
        _saving = true;
        _conflictMessage = null;
        StateHasChanged();

        try
        {
            _currentContent = await _module!.InvokeAsync<string>("getContent", _editorId);
            _note.Content = _currentContent;
            _isDirty = false;

            var originalHash = _note.ContentHash;
            var result = await Session.Notes.SaveAsync(_note, originalHash);

            if (result == SaveResult.Conflict)
            {
                _conflictMessage = "Conflict detected — a [CONFLICT] note was created. Reloading…";
                // Reload to get the server's version
                var fresh = await Session.Notes.GetByIdAsync(NoteId);
                if (fresh is not null)
                {
                    _note = fresh;
                    await _module!.InvokeVoidAsync("setContent", _editorId, _note.Content);
                }
            }
            else
            {
                // Reload to get updated hash
                var fresh = await Session.Notes.GetByIdAsync(NoteId);
                if (fresh is not null) _note = fresh;
            }

            var affected = await Session.Notes.UpdateLinkTitlesAsync(NoteId, _note.Title);
            Notifier.NotifyChanged(NoteId);
            foreach (var id in affected) Notifier.NotifyChanged(id);
        }
        finally
        {
            _saving = false;
            StateHasChanged();
        }
    }

    private void HandleChange(Guid id)
    {
        if (id != NoteId) return;
        _ = InvokeAsync(async () =>
        {
            await ReloadContentAsync();
            StateHasChanged();
        });
    }

    private async Task ReloadContentAsync()
    {
        if (Session.Notes is null) return;
        var fresh = await Session.Notes.GetByIdAsync(NoteId);
        if (fresh is null || _module is null) return;

        _note = fresh;
        if (!_titleDirty) _currentTitle = fresh.Title;
        await _module.InvokeVoidAsync("setContent", _editorId, _note.Content);
    }

    public async ValueTask DisposeAsync()
    {
        Notifier.NoteChanged -= HandleChange;

        // Cancel pending debounced save, then do a final quiet save if there are
        // unsaved edits. _currentContent is already current server-side (kept up to
        // date by OnContentChanged), so no JS interop is needed here.
        _saveCts?.Cancel();
        _saveCts?.Dispose();
        if (_isDirty && _note is not null && Session.Notes is not null)
        {
            try
            {
                _note.Content = _currentContent;
                await Session.Notes.SaveAsync(_note, _note.ContentHash);
            }
            catch { }
        }

        if (_module is not null)
        {
            try
            {
                await _module.InvokeVoidAsync("destroy", _editorId);
                await _module.DisposeAsync();
            }
            catch (JSDisconnectedException) { }
            catch (JSException) { }
        }

        _dotNetRef?.Dispose();
    }
}
