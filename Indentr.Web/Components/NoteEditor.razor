@inject AppSession Session
@inject NoteChangeNotifier Notifier
@inject IJSRuntime JS
@inject NavigationManager Nav
@implements IAsyncDisposable

@if (_note is not null)
{
    <div class="note-editor">
        <div class="note-header">
            <h1 class="note-title">@_note.Title</h1>
            <div class="note-actions">
                @if (_saving)
                {
                    <span class="status-text">Saving…</span>
                }
                else if (_conflictMessage is not null)
                {
                    <span class="status-conflict">@_conflictMessage</span>
                }
                <button class="btn-save" @onclick="SaveAsync" disabled="@_saving">Save</button>
            </div>
        </div>

        @if (_attachments.Count > 0)
        {
            <div class="attachments">
                <strong>Attachments:</strong>
                @foreach (var att in _attachments)
                {
                    <a href="/api/attachments/@att.Id" target="_blank" class="attachment-link">
                        @att.Filename
                    </a>
                }
            </div>
        }

        <div id="@_editorId" class="cm-host"></div>
    </div>
}
else if (_notFound)
{
    <div class="note-missing">Note not found.</div>
}
else
{
    <div class="note-missing">Loading…</div>
}

@code {
    [Parameter, EditorRequired] public Guid NoteId { get; set; }

    private Note?   _note;
    private bool    _notFound;
    private bool    _saving;
    private string? _conflictMessage;
    private string  _currentContent = "";
    private string  _editorId = "";
    private IReadOnlyList<AttachmentMeta> _attachments = [];

    private IJSObjectReference?         _module;
    private DotNetObjectReference<NoteEditor>? _dotNetRef;

    protected override async Task OnInitializedAsync()
    {
        _editorId = $"cm-{NoteId:N}";
        Notifier.NoteChanged += HandleChange;
        await LoadNoteAsync();
    }

    private async Task LoadNoteAsync()
    {
        if (Session.Notes is null || Session.Attachments is null || Session.CurrentUser is null) return;

        var note = await Session.Notes.GetByIdAsync(NoteId);
        if (note is null) { _notFound = true; return; }

        // Privacy guard
        if (note.IsPrivate && note.CreatedBy != Session.CurrentUser.Id)
        {
            Nav.NavigateTo("/");
            return;
        }

        _note = note;
        _currentContent = note.Content;
        _attachments = await Session.Attachments.ListForNoteAsync(NoteId);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender || _note is null) return;

        _module     = await JS.InvokeAsync<IJSObjectReference>("import", "/js/editor.js");
        _dotNetRef  = DotNetObjectReference.Create(this);
        await _module.InvokeVoidAsync("create", _editorId, _note.Content, _dotNetRef);
    }

    [JSInvokable]
    public void OnContentChanged(string content) => _currentContent = content;

    [JSInvokable]
    public void OnLinkClicked(string target)
    {
        if (target.StartsWith("note:") && Guid.TryParse(target[5..], out var id))
            _ = JS.InvokeVoidAsync("open", $"/note/{id}", "_blank");
        else if (!target.StartsWith("kanban:"))
            _ = JS.InvokeVoidAsync("open", target, "_blank");
    }

    private async Task SaveAsync()
    {
        if (_note is null || Session.Notes is null) return;
        _saving = true;
        _conflictMessage = null;
        StateHasChanged();

        try
        {
            _currentContent = await _module!.InvokeAsync<string>("getContent", _editorId);
            _note.Content = _currentContent;

            var originalHash = _note.ContentHash;
            var result = await Session.Notes.SaveAsync(_note, originalHash);

            if (result == SaveResult.Conflict)
            {
                _conflictMessage = "Conflict detected — a [CONFLICT] note was created. Reloading…";
                // Reload to get the server's version
                var fresh = await Session.Notes.GetByIdAsync(NoteId);
                if (fresh is not null)
                {
                    _note = fresh;
                    await _module!.InvokeVoidAsync("setContent", _editorId, _note.Content);
                }
            }
            else
            {
                // Reload to get updated hash
                var fresh = await Session.Notes.GetByIdAsync(NoteId);
                if (fresh is not null) _note = fresh;
            }

            var affected = await Session.Notes.UpdateLinkTitlesAsync(NoteId, _note.Title);
            Notifier.NotifyChanged(NoteId);
            foreach (var id in affected) Notifier.NotifyChanged(id);
        }
        finally
        {
            _saving = false;
            StateHasChanged();
        }
    }

    private void HandleChange(Guid id)
    {
        if (id != NoteId) return;
        _ = InvokeAsync(async () =>
        {
            await ReloadContentAsync();
            StateHasChanged();
        });
    }

    private async Task ReloadContentAsync()
    {
        if (Session.Notes is null) return;
        var fresh = await Session.Notes.GetByIdAsync(NoteId);
        if (fresh is null || _module is null) return;

        _note = fresh;
        await _module.InvokeVoidAsync("setContent", _editorId, _note.Content);
    }

    public async ValueTask DisposeAsync()
    {
        Notifier.NoteChanged -= HandleChange;

        if (_module is not null)
        {
            try { await _module.InvokeVoidAsync("destroy", _editorId); } catch { }
            await _module.DisposeAsync();
        }

        _dotNetRef?.Dispose();
    }
}
