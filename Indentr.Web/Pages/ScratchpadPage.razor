@page "/scratchpad"
@inject AppSession Session
@inject IJSRuntime JS
@implements IAsyncDisposable

<PageTitle>Scratchpad — Indentr</PageTitle>

<div class="scratchpad-page">
    <div class="note-header">
        <h1 class="note-title">Scratchpad</h1>
        <div class="note-actions">
            @if (_saving)
            {
                <span class="status-text">Saving…</span>
            }
            else if (_conflictMessage is not null)
            {
                <span class="status-conflict">@_conflictMessage</span>
            }
            <button class="btn-save" @onclick="SaveAsync" disabled="@(_saving || _pad is null)">Save</button>
        </div>
    </div>
    <div id="@_editorId" class="cm-host"></div>
</div>

@code {
    private Scratchpad? _pad;
    private bool   _saving;
    private bool   _isDirty;
    private string? _conflictMessage;
    private string _currentContent = "";
    private string _editorId = "cm-scratchpad";
    private CancellationTokenSource? _saveCts;

    private IJSObjectReference?              _module;
    private DotNetObjectReference<ScratchpadPage>? _dotNetRef;
    private bool _editorInitialized;

    protected override async Task OnInitializedAsync()
    {
        if (Session.Scratchpads is null || Session.CurrentUser is null) return;
        _pad = await Session.Scratchpads.GetOrCreateForUserAsync(Session.CurrentUser.Id);
        _currentContent = _pad.Content;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_editorInitialized || _pad is null) return;
        _editorInitialized = true; // guard before first await to prevent double-init

        _module    = await JS.InvokeAsync<IJSObjectReference>("import", "/js/editor.js");
        _dotNetRef = DotNetObjectReference.Create(this);
        await _module.InvokeVoidAsync("create", _editorId, _pad.Content, _dotNetRef);
    }

    [JSInvokable]
    public void OnContentChanged(string content)
    {
        _currentContent = content;
        _isDirty = true;

        _saveCts?.Cancel();
        _saveCts?.Dispose();
        _saveCts = new CancellationTokenSource();
        var token = _saveCts.Token;
        _ = Task.Run(async () =>
        {
            try
            {
                await Task.Delay(3000, token);
                await InvokeAsync(SaveAsync);
            }
            catch (OperationCanceledException) { }
        });
    }
    [JSInvokable] public Task SaveFromKeyboard() => SaveAsync();
    [JSInvokable] public void OnLinkClicked(string target) { } // no-op for scratchpad

    private async Task SaveAsync()
    {
        if (_pad is null || Session.Scratchpads is null) return;
        _saving = true;
        _conflictMessage = null;
        StateHasChanged();

        try
        {
            _currentContent = await _module!.InvokeAsync<string>("getContent", _editorId);
            _pad.Content = _currentContent;
            _isDirty = false;
            var originalHash = _pad.ContentHash;
            var result = await Session.Scratchpads.SaveAsync(_pad, originalHash);

            if (result == SaveResult.Conflict)
            {
                _conflictMessage = "Conflict — reloading server version…";
                _pad = await Session.Scratchpads.GetOrCreateForUserAsync(Session.CurrentUser!.Id);
                await _module!.InvokeVoidAsync("setContent", _editorId, _pad.Content);
            }
            else
            {
                // Refresh hash
                _pad = await Session.Scratchpads.GetOrCreateForUserAsync(Session.CurrentUser!.Id);
            }
        }
        finally
        {
            _saving = false;
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        _saveCts?.Cancel();
        _saveCts?.Dispose();
        if (_isDirty && _pad is not null && Session.Scratchpads is not null)
        {
            try
            {
                _pad.Content = _currentContent;
                await Session.Scratchpads.SaveAsync(_pad, _pad.ContentHash);
            }
            catch { }
        }

        if (_module is not null)
        {
            try
            {
                await _module.InvokeVoidAsync("destroy", _editorId);
                await _module.DisposeAsync();
            }
            catch (JSDisconnectedException) { }
            catch (JSException) { }
        }
        _dotNetRef?.Dispose();
    }
}
